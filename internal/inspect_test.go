//nolint:funlen
package internal_test

import (
	"bytes"
	"io/fs"
	"strings"
	"testing"
	"testing/fstest"

	"github.com/slavsan/gocov/internal"
)

func TestInspect(t *testing.T) { //nolint:maintidx
	testCases := []struct {
		title            string
		fsys             fs.StatFS
		config           *internal.Config
		args             []string
		expectedStdout   string
		expectedStderr   string
		expectedExitCode int
	}{
		{
			title: "when printing the entire file",
			fsys: fstest.MapFS{
				"go.mod":       {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(exampleCoverageOut3)},
				"cmd/gocov.go": {Data: []byte(strings.Join([]string{
					`package cmd`,
					``,
					`import (`,
					`	"os"`,
					``,
					`	"github.com/slavsan/gocov/internal"`,
					`)`,
					``,
					`func Exec() {`,
					`	var args []string`,
					`	config := &internal.Config{}`,
					`	config.Color = true`,
					``,
					`	command := internal.Report`,
					``,
					`	if len(os.Args) > 1 {`,
					`		switch os.Args[1] {`,
					`		case "check":`,
					`			command = internal.Check`,
					`		case "inspect":`,
					`			command = internal.Inspect`,
					`			if len(os.Args) > 2 {`,
					`				args = append(args, os.Args[2])`,
					`			}`,
					`			//os.Args[1]`,
					`		}`,
					`	}`,
					``,
					`	internal.Exec(`,
					`		command,`,
					`		args,`,
					`		os.Stdout,`,
					`		os.Stderr,`,
					`		os.DirFS("."),`,
					`		config,`,
					`		&internal.ProcessExiter{},`,
					`	)`,
					`}`,
					``,
				}, "\n"))},
			},
			args: []string{"gocov/cmd/gocov.go"},
			config: &internal.Config{
				Color:     false,
				ExactPath: true,
			},
			expectedStdout: strings.Join([]string{
				` 1| package cmd`,
				` 2| `,
				` 3| import (`,
				` 4| 	"os"`,
				` 5| `,
				` 6| 	"github.com/slavsan/gocov/internal"`,
				` 7| )`,
				` 8| `,
				` 9| func Exec() ` + internal.Red + `{`,
				`10| 	var args []string`,
				`11| 	config := &internal.Config{}`,
				`12| 	config.Color = true`,
				`13| `,
				`14| 	command := internal.Report`,
				`15| `,
				`16| 	if len(os.Args) > 1 ` + internal.NoColor + internal.Red + `{`,
				`17| 		switch os.Args[1] ` + internal.NoColor + `{`,
				`18| 		case "check":` + internal.Red,
				`19| 			command = internal.Check` + internal.NoColor,
				`20| 		case "inspect":` + internal.Red,
				`21| 			command = internal.Inspect`,
				`22| 			if len(os.Args) > 2 ` + internal.NoColor + internal.Red + `{`,
				`23| 				args = append(args, os.Args[2])`,
				`24| 			}` + internal.NoColor,
				`25| 			//os.Args[1]`,
				`26| 		}`,
				`27| 	}`,
				`28| `,
				`29| 	` + internal.Red + `internal.Exec(`,
				`30| 		command,`,
				`31| 		args,`,
				`32| 		os.Stdout,`,
				`33| 		os.Stderr,`,
				`34| 		os.DirFS("."),`,
				`35| 		config,`,
				`36| 		&internal.ProcessExiter{},`,
				`37| 	)` + internal.NoColor,
				`38| }`,
				`39| `,
				``,
			}, "\n"),
			expectedStderr:   "",
			expectedExitCode: 0,
		},
		{
			title: "when no arguments provided",
			fsys: fstest.MapFS{
				"go.mod":       {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(exampleCoverageOut3)},
			},
			config: &internal.Config{
				Color: false,
			},
			args:             []string{},
			expectedStdout:   "",
			expectedStderr:   "no arguments provided to inspect command",
			expectedExitCode: 1,
		},
		{
			title: "when target file which does not exist",
			fsys: fstest.MapFS{
				"go.mod":       {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(exampleCoverageOut3)},
			},
			config: &internal.Config{
				Color:     false,
				ExactPath: true,
			},
			args:             []string{"does/not/exist"},
			expectedStdout:   "",
			expectedStderr:   "failed to open github.com/slavsan/does/not/exist",
			expectedExitCode: 1,
		},
		{
			title: "when not specifying an exact path",
			fsys: fstest.MapFS{
				"go.mod":            {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out":      {Data: []byte(exampleCoverageOut3)},
				"internal/gocov.go": {Data: []byte{}},
				"cmd/gocov.go": {Data: []byte(strings.Join([]string{
					`package cmd`,
					``,
					`import (`,
					`	"os"`,
					``,
					`	"github.com/slavsan/gocov/internal"`,
					`)`,
					``,
					`func Exec() {`,
					`	var args []string`,
					`	config := &internal.Config{}`,
					`	config.Color = true`,
					``,
					`	command := internal.Report`,
					``,
					`	if len(os.Args) > 1 {`,
					`		switch os.Args[1] {`,
					`		case "check":`,
					`			command = internal.Check`,
					`		case "inspect":`,
					`			command = internal.Inspect`,
					`			if len(os.Args) > 2 {`,
					`				args = append(args, os.Args[2])`,
					`			}`,
					`			//os.Args[1]`,
					`		}`,
					`	}`,
					``,
					`	internal.Exec(`,
					`		command,`,
					`		args,`,
					`		os.Stdout,`,
					`		os.Stderr,`,
					`		os.DirFS("."),`,
					`		config,`,
					`		&internal.ProcessExiter{},`,
					`	)`,
					`}`,
					``,
				}, "\n"))},
			},
			args: []string{"gocov.go"},
			config: &internal.Config{
				Color: false,
			},
			expectedStdout: strings.Join([]string{
				`inspect for file: cmd/gocov.go`,
				` 1| package cmd`,
				` 2| `,
				` 3| import (`,
				` 4| 	"os"`,
				` 5| `,
				` 6| 	"github.com/slavsan/gocov/internal"`,
				` 7| )`,
				` 8| `,
				` 9| func Exec() ` + internal.Red + `{`,
				`10| 	var args []string`,
				`11| 	config := &internal.Config{}`,
				`12| 	config.Color = true`,
				`13| `,
				`14| 	command := internal.Report`,
				`15| `,
				`16| 	if len(os.Args) > 1 ` + internal.NoColor + internal.Red + `{`,
				`17| 		switch os.Args[1] ` + internal.NoColor + `{`,
				`18| 		case "check":` + internal.Red,
				`19| 			command = internal.Check` + internal.NoColor,
				`20| 		case "inspect":` + internal.Red,
				`21| 			command = internal.Inspect`,
				`22| 			if len(os.Args) > 2 ` + internal.NoColor + internal.Red + `{`,
				`23| 				args = append(args, os.Args[2])`,
				`24| 			}` + internal.NoColor,
				`25| 			//os.Args[1]`,
				`26| 		}`,
				`27| 	}`,
				`28| `,
				`29| 	` + internal.Red + `internal.Exec(`,
				`30| 		command,`,
				`31| 		args,`,
				`32| 		os.Stdout,`,
				`33| 		os.Stderr,`,
				`34| 		os.DirFS("."),`,
				`35| 		config,`,
				`36| 		&internal.ProcessExiter{},`,
				`37| 	)` + internal.NoColor,
				`38| }`,
				`39| `,
				`skipped 1 other files which matched`,
				``,
			}, "\n"),
			expectedStderr:   "",
			expectedExitCode: 0,
		},
		{
			title: "when the coverage.out file is out of date, end line is out of bound",
			fsys: fstest.MapFS{
				"go.mod":       {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(exampleCoverageOut3)},
				"cmd/gocov.go": {Data: []byte(strings.Join([]string{
					`package cmd`,
					``,
					`import (`,
					`	"os"`,
					``,
					`	"github.com/slavsan/gocov/internal"`,
					`)`,
					``,
					`func Exec() {`,
					`	var args []string`,
					`	config := &internal.Config{}`,
					`	config.Color = true`,
					``,
					`	command := internal.Report`,
					``,
					`	if len(os.Args) > 1 {`,
					`		switch os.Args[1] {`,
					`		case "check":`,
					`			command = internal.Check`,
					`		}`,
					`	}`,
					``,
					`	internal.Exec(`,
					`		command,`,
					`		args,`,
					`		os.Stdout,`,
					`		os.Stderr,`,
					`		os.DirFS("."),`,
					`		config,`,
					`		&internal.ProcessExiter{},`,
					`	)`,
					`}`,
					``,
				}, "\n"))},
			},
			args: []string{"cmd/gocov.go"},
			config: &internal.Config{
				Color: false,
			},
			expectedStdout:   "",
			expectedStderr:   "running inspect failed, please regenerate the coverage report again",
			expectedExitCode: 1,
		},
		{
			title: "when the coverage.out file is out of date, end column is out of bound",
			fsys: fstest.MapFS{
				"go.mod": {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(strings.Join([]string{
					`mode: atomic`,
					`github.com/slavsan/gocov/cmd/gocov.go:1.13,2.22 5 0`,
					``,
				}, "\n"))},
				"cmd/gocov.go": {Data: []byte(strings.Join([]string{
					`package main`,
					``,
					`import (`,
					`	os`,
					`)`,
					``,
					`func Exec() {`,
					`	fmt.Printf("foobar\n")`,
					`}`,
					``,
				}, "\n"))},
			},
			args: []string{"cmd/gocov.go"},
			config: &internal.Config{
				Color: false,
			},
			expectedStdout:   "",
			expectedStderr:   "running inspect failed, please regenerate the coverage report again",
			expectedExitCode: 1,
		},
		{
			title: "when the coverage.out file is out of date, start line is out of bound",
			fsys: fstest.MapFS{
				"go.mod": {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(strings.Join([]string{
					`mode: atomic`,
					`github.com/slavsan/gocov/cmd/gocov.go:20.1,1.1 5 0`,
					``,
				}, "\n"))},
				"cmd/gocov.go": {Data: []byte(strings.Join([]string{
					`package main`,
					``,
					`import (`,
					`	os`,
					`)`,
					``,
					`func Exec() {`,
					`	fmt.Printf("foobar\n")`,
					`}`,
					``,
				}, "\n"))},
			},
			args: []string{"cmd/gocov.go"},
			config: &internal.Config{
				Color: false,
			},
			expectedStdout:   "",
			expectedStderr:   "running inspect failed, please regenerate the coverage report again",
			expectedExitCode: 1,
		},
		{
			title: "when the coverage.out file is out of date, start column is out of bound",
			fsys: fstest.MapFS{
				"go.mod": {Data: []byte(`module github.com/slavsan/gospec`)},
				"coverage.out": {Data: []byte(strings.Join([]string{
					`mode: atomic`,
					`github.com/slavsan/gocov/cmd/gocov.go:2.20,1.1 5 0`,
					``,
				}, "\n"))},
				"cmd/gocov.go": {Data: []byte(strings.Join([]string{
					`package main`,
					``,
					`import (`,
					`	os`,
					`)`,
					``,
					`func Exec() {`,
					`	fmt.Printf("foobar\n")`,
					`}`,
					``,
				}, "\n"))},
			},
			args: []string{"cmd/gocov.go"},
			config: &internal.Config{
				Color: false,
			},
			expectedStdout:   "",
			expectedStderr:   "running inspect failed, please regenerate the coverage report again",
			expectedExitCode: 1,
		},
	}

	for _, tc := range testCases {
		tc := tc
		t.Run(tc.title, func(t *testing.T) {
			var stdout bytes.Buffer
			var stderr bytes.Buffer
			exiter := &exiterMock{}
			internal.NewCommand(&stdout, &stderr, tc.fsys, tc.config, exiter, &fileWriterMock{}).Exec(internal.Inspect, tc.args)
			if tc.expectedStdout != stdout.String() {
				t.Errorf("table does not match\n\texpected:\n`%s`\n\tactual:\n`%s`\n", tc.expectedStdout, stdout.String())
			}
			if tc.expectedStderr != stderr.String() {
				t.Errorf("table does not match\n\texpected:\n`%s`\n\tactual:\n`%s`\n", tc.expectedStderr, stderr.String())
			}
			if tc.expectedExitCode != exiter.code {
				t.Errorf("exit code does not match\n\texpected:\n`%d`\n\tactual:\n`%d`\n", tc.expectedExitCode, exiter.code)
			}
		})
	}
}
